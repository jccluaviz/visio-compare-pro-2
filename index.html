<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VisioCompare Pro - Suite Forense</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              slate: { 850: '#151f32' }
            },
            cursor: {
              'ew-resize': 'ew-resize',
            }
          }
        }
      }
    </script>

    <!-- Custom Scrollbar Styles -->
    <style>
      ::-webkit-scrollbar { width: 8px; height: 8px; }
      ::-webkit-scrollbar-track { background: #1e293b; }
      ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
      ::-webkit-scrollbar-thumb:hover { background: #64748b; }
      .scrollbar-hide::-webkit-scrollbar { display: none; }
      .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
    </style>

    <!-- Babel Standalone for in-browser compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.554.0",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.30.0",
    "exifr": "https://aistudiocdn.com/exifr@^7.1.3"
  }
}
</script>
</head>
  <body class="bg-slate-900 text-white overflow-hidden antialiased">
    <div id="root" class="h-screen w-screen flex flex-col"></div>

    <!-- Application Logic -->
    <script type="text/babel" data-type="module">
      import React, { useState, useEffect, useRef, useCallback } from 'https://esm.sh/react@18.2.0';
      import { createRoot } from 'https://esm.sh/react-dom@18.2.0/client';
      import { 
        Upload, X, Image as ImageIcon, Info, Sparkles, Columns, SquareStack, 
        SlidersHorizontal, Divide, Eye, Search, ShieldAlert, ZoomIn, ZoomOut, 
        Move, MousePointer2, FileType, Maximize, HardDrive, Calendar, Camera, 
        Aperture, Timer, MapPin, Sliders, AlertCircle, RefreshCw, Wand2, 
        Download, ArrowLeft, ArrowRight 
      } from 'https://esm.sh/lucide-react@0.263.1';
      import exifr from 'https://esm.sh/exifr@7.1.3';
      import { GoogleGenAI } from 'https://esm.sh/@google/genai@0.1.1';

      // --- TYPES ---
      const ComparisonMode = {
        SLIDER: 'SLIDER',
        SIDE_BY_SIDE: 'SIDE_BY_SIDE',
        OVERLAY: 'OVERLAY',
        DIFFERENCE: 'DIFFERENCE',
        BLINK: 'BLINK',
        LOUPE: 'LOUPE',
        ELA: 'ELA',
      };

      const PHOTO_PRESETS = [
        { label: "Seleccionar retoque...", prompt: "" },
        { label: "Corrección Exposición (+0.5 EV)", prompt: "Increase exposure slightly by 0.5 EV, brightening the image naturally." },
        { label: "Corrección Exposición (-0.5 EV)", prompt: "Decrease exposure slightly by 0.5 EV, darkening the image to recover highlights." },
        { label: "Aumentar Contraste (Punchy)", prompt: "Increase contrast to make shadows deeper and highlights brighter, giving a punchy look." },
        { label: "Contraste Suave (Matte)", prompt: "Reduce contrast slightly and lift the blacks for a matte, soft vintage look." },
        { label: "Balance de Blancos: Cálido", prompt: "Shift white balance towards warm, golden tones." },
        { label: "Balance de Blancos: Frío", prompt: "Shift white balance towards cool, blue tones." },
        { label: "Aumentar Saturación (Vibrance)", prompt: "Increase saturation and vibrance to make colors pop without oversaturating skin tones." },
        { label: "Desaturar (Muted Tones)", prompt: "Reduce saturation for a muted, cinematic look." },
        { label: "Máscara de Enfoque (Sharpen)", prompt: "Apply sharpening to enhance edges and details." },
        { label: "Reducción de Ruido", prompt: "Apply noise reduction to smooth out grain while keeping details." },
        { label: "Recuperar Sombras", prompt: "Lift the shadows to reveal details in dark areas." },
        { label: "Recuperar Luces Altas", prompt: "Dim the highlights to recover blown-out details." },
        { label: "Claridad (Clarity)", prompt: "Increase clarity and local contrast to enhance texture." },
        { label: "Eliminar Neblina (Dehaze)", prompt: "Remove haze and atmospheric fog to make the image clearer." },
        { label: "Viñeteado Sutil", prompt: "Add a subtle dark vignette around the corners to draw attention to the center." },
        { label: "Corrección Gamma (Brillo Medio)", prompt: "Adjust gamma to brighten midtones." },
        { label: "Rango Dinámico (HDR Natural)", prompt: "Maximize dynamic range, balancing extreme lights and darks naturally." },
        { label: "Suavizar Piel (Retrato)", prompt: "Softly smooth skin textures while keeping facial features sharp." },
        { label: "Realzar Detalles (Estructura)", prompt: "Enhance fine structure and micro-contrast." },
        { label: "Punto Negro (Black Point)", prompt: "Lower the black point to ensure true blacks." },
      ];

      // --- SERVICES: Image Processing ---
      const calculateDifference = async (imgA, imgB) => {
        return new Promise((resolve, reject) => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          if (!ctx) { reject('No context'); return; }

          const width = Math.max(imgA.width, imgB.width);
          const height = Math.max(imgA.height, imgB.height);
          canvas.width = width;
          canvas.height = height;

          const image1 = new Image();
          const image2 = new Image();
          image1.crossOrigin = "Anonymous";
          image2.crossOrigin = "Anonymous";

          let loadedCount = 0;
          const onLoad = () => {
            loadedCount++;
            if (loadedCount === 2) process();
          };

          image1.onload = onLoad;
          image2.onload = onLoad;
          image1.onerror = reject;
          image2.onerror = reject;
          image1.src = imgA.url;
          image2.src = imgB.url;

          function process() {
            const drawContain = (img) => {
              const scale = Math.min(width / img.width, height / img.height);
              const w = img.width * scale;
              const h = img.height * scale;
              ctx.drawImage(img, (width - w) / 2, (height - h) / 2, w, h);
            }

            ctx.clearRect(0, 0, width, height);
            drawContain(image1);
            const dataA = ctx.getImageData(0, 0, width, height).data;

            ctx.clearRect(0, 0, width, height);
            drawContain(image2);
            const dataB = ctx.getImageData(0, 0, width, height).data;

            const diffImg = ctx.createImageData(width, height);
            const diffData = diffImg.data;

            for (let i = 0; i < dataA.length; i += 4) {
              const a1 = dataA[i + 3];
              const a2 = dataB[i + 3];

              if (a1 === 0 && a2 === 0) {
                diffData[i+3] = 0;
              } else {
                const rDiff = Math.abs(dataA[i] - dataB[i]);
                const gDiff = Math.abs(dataA[i+1] - dataB[i+1]);
                const bDiff = Math.abs(dataA[i+2] - dataB[i+2]);
                const totalDiff = rDiff + gDiff + bDiff;

                if (totalDiff > 10) {
                  diffData[i] = rDiff + 100;
                  diffData[i+1] = gDiff;
                  diffData[i+2] = bDiff;
                  diffData[i+3] = 255;
                } else {
                  diffData[i+3] = 255; // Black
                }
              }
            }
            ctx.putImageData(diffImg, 0, 0);
            resolve(canvas.toDataURL());
          }
        });
      };

      const generateELA = async (img, quality = 0.90, scale = 40) => {
        return new Promise((resolve, reject) => {
          const image = new Image();
          image.crossOrigin = "Anonymous";
          image.src = img.url;
          image.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;

            ctx.drawImage(image, 0, 0);
            const originalData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            const compressedUrl = canvas.toDataURL('image/jpeg', quality);
            const compressedImage = new Image();
            compressedImage.src = compressedUrl;
            
            compressedImage.onload = () => {
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(compressedImage, 0, 0);
              const compressedData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              const output = ctx.createImageData(canvas.width, canvas.height);
              
              for (let i = 0; i < originalData.data.length; i += 4) {
                output.data[i] = Math.abs(originalData.data[i] - compressedData.data[i]) * scale;
                output.data[i+1] = Math.abs(originalData.data[i+1] - compressedData.data[i+1]) * scale;
                output.data[i+2] = Math.abs(originalData.data[i+2] - compressedData.data[i+2]) * scale;
                output.data[i+3] = 255;
              }
              ctx.putImageData(output, 0, 0);
              resolve(canvas.toDataURL());
            };
          };
          image.onerror = reject;
        });
      };

      // --- SERVICES: Gemini AI ---
      const fileToBase64 = (file) => {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.readAsDataURL(file);
          reader.onload = () => resolve(reader.result.split(',')[1]);
          reader.onerror = reject;
        });
      };

      const analyzeImageDifference = async (imageA, imageB) => {
        if (!process.env.API_KEY) throw new Error("API Key no configurada");
        const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
        const base64A = await fileToBase64(imageA.file);
        const base64B = await fileToBase64(imageB.file);
        
        const response = await ai.models.generateContent({
          model: 'gemini-2.5-flash',
          contents: {
            parts: [
              { text: "Imagen A:" }, { inlineData: { mimeType: imageA.type, data: base64A } },
              { text: "Imagen B:" }, { inlineData: { mimeType: imageB.type, data: base64B } },
              { text: "Compara detalladamente estas dos imágenes. Lista diferencias visuales (color, luz, composición), posibles ediciones y datos técnicos. Sé conciso." }
            ]
          }
        });
        return response.text;
      };

      const editImageWithGenAI = async (image, prompt) => {
        if (!process.env.API_KEY) throw new Error("API Key no configurada");
        const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
        const base64 = await fileToBase64(image.file);

        const response = await ai.models.generateContent({
          model: 'gemini-2.5-flash-image',
          contents: {
            parts: [
              { inlineData: { mimeType: image.type, data: base64 } },
              { text: `Edita esta imagen siguiendo estrictamente: ${prompt}. Mantén la estructura original.` }
            ]
          }
        });

        const parts = response.candidates?.[0]?.content?.parts;
        if (parts) {
            for (const part of parts) {
                if (part.inlineData?.data) return `data:image/png;base64,${part.inlineData.data}`;
            }
        }
        throw new Error("No se generó imagen");
      };

      // --- COMPONENTS ---

      const ToolButton = ({ active, onClick, icon, label, disabled }) => (
        <button
          onClick={onClick}
          disabled={disabled}
          className={`flex items-center gap-2 px-3 py-2 rounded-md text-sm font-medium transition-all whitespace-nowrap
            ${active ? 'bg-slate-700 text-sky-400 shadow-sm ring-1 ring-slate-600' : 'text-slate-400 hover:text-slate-200 hover:bg-slate-800'}
            ${disabled ? 'opacity-40 cursor-not-allowed' : ''}`}
          title={label}
        >
          {icon} <span className="hidden xl:inline">{label}</span>
        </button>
      );

      const Header = ({ mode, setMode, hasImages, showMetadata, toggleMetadata, showAI, toggleAI }) => (
        <header className="h-16 bg-slate-800 border-b border-slate-700 flex items-center justify-between px-4 md:px-6 shadow-md z-30 shrink-0">
          <div className="flex items-center gap-3">
            <div className="w-8 h-8 bg-sky-500 rounded-lg flex items-center justify-center text-white font-bold text-lg shadow-lg">V</div>
            <h1 className="font-bold text-xl tracking-tight text-slate-100 hidden md:block">Visio<span className="text-sky-400">Compare</span> <span className="text-xs text-slate-500 align-top ml-1">PRO</span></h1>
          </div>
          <div className="flex-1 max-w-4xl flex items-center justify-center gap-2 overflow-x-auto px-4 scrollbar-hide">
            <div className="bg-slate-900/50 p-1 rounded-lg border border-slate-700 flex gap-1">
              <ToolButton active={mode === ComparisonMode.SLIDER} onClick={() => setMode(ComparisonMode.SLIDER)} icon={<SlidersHorizontal size={16} />} label="Deslizar" disabled={!hasImages} />
              <ToolButton active={mode === ComparisonMode.SIDE_BY_SIDE} onClick={() => setMode(ComparisonMode.SIDE_BY_SIDE)} icon={<Columns size={16} />} label="Lado a Lado" disabled={!hasImages} />
              <ToolButton active={mode === ComparisonMode.BLINK} onClick={() => setMode(ComparisonMode.BLINK)} icon={<Eye size={16} />} label="Parpadeo" disabled={!hasImages} />
              <ToolButton active={mode === ComparisonMode.LOUPE} onClick={() => setMode(ComparisonMode.LOUPE)} icon={<Search size={16} />} label="Lupa" disabled={!hasImages} />
              <div className="w-px bg-slate-700 mx-1 my-1"></div>
              <ToolButton active={mode === ComparisonMode.OVERLAY} onClick={() => setMode(ComparisonMode.OVERLAY)} icon={<SquareStack size={16} />} label="Opacidad" disabled={!hasImages} />
              <ToolButton active={mode === ComparisonMode.DIFFERENCE} onClick={() => setMode(ComparisonMode.DIFFERENCE)} icon={<Divide size={16} />} label="Diferencia" disabled={!hasImages} />
              <ToolButton active={mode === ComparisonMode.ELA} onClick={() => setMode(ComparisonMode.ELA)} icon={<ShieldAlert size={16} />} label="Forense (ELA)" disabled={!hasImages} />
            </div>
          </div>
          <div className="flex items-center gap-2">
            <button onClick={toggleAI} disabled={!hasImages} className={`p-2 rounded-lg transition-all flex items-center gap-2 border ${showAI ? 'bg-indigo-600 text-white border-indigo-500' : 'text-slate-400 hover:text-indigo-400 border-transparent hover:bg-slate-700'} ${!hasImages ? 'opacity-50 cursor-not-allowed' : ''}`}>
              <Sparkles size={18} /> <span className="hidden lg:inline font-medium text-sm">IA</span>
            </button>
            <button onClick={toggleMetadata} disabled={!hasImages} className={`p-2 rounded-lg transition-colors border ${showMetadata ? 'bg-slate-700 text-sky-400 border-slate-600' : 'text-slate-400 hover:text-slate-100 border-transparent hover:bg-slate-700'} ${!hasImages ? 'opacity-50 cursor-not-allowed' : ''}`}>
              <Info size={20} />
            </button>
          </div>
        </header>
      );

      const DropZone = ({ side, image, onFileLoaded, onRemove }) => {
        const [isDragOver, setIsDragOver] = useState(false);
        const inputRef = useRef(null);

        const handleDrop = (e) => {
          e.preventDefault(); setIsDragOver(false);
          if (e.dataTransfer.files?.[0]?.type.startsWith('image/')) onFileLoaded(e.dataTransfer.files[0]);
        };

        if (image) {
          return (
            <div className="relative w-full h-64 md:h-96 rounded-xl overflow-hidden border-2 border-slate-600 bg-slate-800 group shadow-lg">
              <img src={image.url} alt={side} className="w-full h-full object-contain p-2" />
              <div className="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
                <button onClick={onRemove} className="p-2 bg-red-500 hover:bg-red-600 text-white rounded-full"><X size={24} /></button>
              </div>
              <div className="absolute top-2 left-2 bg-blue-500 px-2 py-1 rounded text-xs font-bold text-white shadow-sm">{side === 'left' ? 'Imagen A' : 'Imagen B'}</div>
            </div>
          );
        }

        return (
          <div onClick={() => inputRef.current?.click()} onDragOver={(e) => {e.preventDefault(); setIsDragOver(true)}} onDragLeave={() => setIsDragOver(false)} onDrop={handleDrop}
            className={`w-full h-64 md:h-96 rounded-xl border-2 border-dashed flex flex-col items-center justify-center cursor-pointer transition-all duration-300 ${isDragOver ? 'border-sky-400 bg-sky-400/10 scale-[1.02]' : 'border-slate-600 bg-slate-800/50 hover:bg-slate-800'}`}>
            <input type="file" ref={inputRef} onChange={(e) => e.target.files?.[0] && onFileLoaded(e.target.files[0])} accept="image/*" className="hidden" />
            <div className="p-4 bg-slate-700/50 rounded-full mb-4 text-sky-400"><Upload size={32} /></div>
            <h3 className="text-lg font-medium text-slate-200 mb-1">{side === 'left' ? 'Cargar Imagen A' : 'Cargar Imagen B'}</h3>
          </div>
        );
      };

      const ImageViewer = ({ leftImage, rightImage, mode }) => {
        const [sliderPosition, setSliderPosition] = useState(50);
        const [opacity, setOpacity] = useState(50);
        const [blinkActive, setBlinkActive] = useState(false);
        const [blinkSpeed, setBlinkSpeed] = useState(500);
        const [zoom, setZoom] = useState(1);
        const [pan, setPan] = useState({ x: 0, y: 0 });
        const [isPanning, setIsPanning] = useState(false);
        const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
        const [diffUrl, setDiffUrl] = useState(null);
        const [elaA, setElaA] = useState(null);
        const [elaB, setElaB] = useState(null);
        const [loading, setLoading] = useState(false);
        
        const containerRef = useRef(null);
        const lastMousePos = useRef({ x: 0, y: 0 });
        const isDraggingSlider = useRef(false);

        useEffect(() => { setZoom(1); setPan({x:0, y:0}); }, [mode]);
        
        useEffect(() => {
          if (mode !== ComparisonMode.BLINK) return;
          const interval = setInterval(() => setBlinkActive(p => !p), blinkSpeed);
          return () => clearInterval(interval);
        }, [mode, blinkSpeed]);

        useEffect(() => {
          if (mode === ComparisonMode.DIFFERENCE) {
            setLoading(true);
            calculateDifference(leftImage, rightImage).then(u => { setDiffUrl(u); setLoading(false); });
          }
          if (mode === ComparisonMode.ELA) {
            setLoading(true);
            Promise.all([generateELA(leftImage), generateELA(rightImage)]).then(([a, b]) => { setElaA(a); setElaB(b); setLoading(false); });
          }
        }, [mode, leftImage, rightImage]);

        const handleWheel = (e) => {
          if (mode === ComparisonMode.SLIDER || mode === ComparisonMode.LOUPE) return;
          e.preventDefault();
          const delta = -e.deltaY * 0.001;
          setZoom(Math.min(Math.max(1, zoom + delta * 10), 8));
          if (zoom <= 1) setPan({x:0, y:0});
        };

        const handleMouseDown = (e) => {
          if (mode === ComparisonMode.SLIDER) isDraggingSlider.current = true;
          else if (zoom > 1) { setIsPanning(true); lastMousePos.current = { x: e.clientX, y: e.clientY }; }
        };

        const handleMouseMove = (e) => {
          if (mode === ComparisonMode.SLIDER && isDraggingSlider.current && containerRef.current) {
            const rect = containerRef.current.getBoundingClientRect();
            setSliderPosition(Math.max(0, Math.min(e.clientX - rect.left, rect.width)) / rect.width * 100);
          }
          if (isPanning && zoom > 1) {
            const dx = e.clientX - lastMousePos.current.x;
            const dy = e.clientY - lastMousePos.current.y;
            setPan(p => ({ x: p.x + dx, y: p.y + dy }));
            lastMousePos.current = { x: e.clientX, y: e.clientY };
          }
          if (mode === ComparisonMode.LOUPE && containerRef.current) {
            const rect = containerRef.current.getBoundingClientRect();
            setMousePos({ x: e.clientX - rect.left, y: e.clientY - rect.top });
          }
        };

        const style = { transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`, transformOrigin: 'center', transition: isPanning ? 'none' : 'transform 0.1s' };
        const imgStyle = { position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', objectFit: 'contain', userSelect: 'none' };
        
        const ZoomControls = () => (
          mode === ComparisonMode.SLIDER || mode === ComparisonMode.LOUPE ? null :
          <div className="absolute bottom-4 right-4 bg-slate-900/80 backdrop-blur p-1 rounded-lg border border-slate-600 flex flex-col gap-1 z-50">
            <button className="p-2 hover:bg-slate-700 rounded text-sky-400" onClick={() => setZoom(Math.min(zoom + 0.5, 8))}><ZoomIn size={20}/></button>
            <div className="text-xs text-center text-slate-400">{Math.round(zoom * 100)}%</div>
            <button className="p-2 hover:bg-slate-700 rounded text-sky-400" onClick={() => setZoom(Math.max(zoom - 0.5, 1))}><ZoomOut size={20}/></button>
            {zoom > 1 && <button className="p-2 hover:bg-slate-700 rounded text-red-400 border-t border-slate-700" onClick={() => {setZoom(1); setPan({x:0, y:0})}}><Move size={20}/></button>}
          </div>
        );

        if (mode === ComparisonMode.SIDE_BY_SIDE) return (
          <div className="w-full h-full flex gap-1 overflow-hidden relative" onWheel={handleWheel} onMouseDown={handleMouseDown} onMouseUp={() => setIsPanning(false)} onMouseMove={handleMouseMove} onMouseLeave={() => setIsPanning(false)}>
            <div className="flex-1 relative bg-slate-900/50 border-r border-slate-700 overflow-hidden">
              <div className="w-full h-full" style={style}><img src={leftImage.url} style={imgStyle} /></div>
              <span className="absolute top-2 left-2 bg-black/60 text-white px-2 py-1 text-xs rounded">A</span>
            </div>
            <div className="flex-1 relative bg-slate-900/50 overflow-hidden">
              <div className="w-full h-full" style={style}><img src={rightImage.url} style={imgStyle} /></div>
              <span className="absolute top-2 right-2 bg-black/60 text-white px-2 py-1 text-xs rounded">B</span>
            </div>
            <ZoomControls />
          </div>
        );

        if (mode === ComparisonMode.BLINK) return (
          <div className="w-full h-full relative overflow-hidden" onWheel={handleWheel} onMouseDown={handleMouseDown} onMouseUp={() => setIsPanning(false)} onMouseMove={handleMouseMove}>
            <div className="w-full h-full relative" style={style}>
              <img src={blinkActive ? rightImage.url : leftImage.url} style={imgStyle} />
            </div>
            <div className="absolute top-4 left-1/2 -translate-x-1/2 bg-slate-900/80 backdrop-blur px-4 py-2 rounded-full border border-sky-500/30 z-50 flex items-center gap-3">
              <span className={`text-xs font-bold w-6 h-6 rounded flex items-center justify-center ${!blinkActive ? 'bg-sky-500 text-white' : 'bg-slate-700'}`}>A</span>
              <input type="range" min="100" max="1000" step="50" value={blinkSpeed} onChange={e => setBlinkSpeed(Number(e.target.value))} className="w-32 h-1 bg-slate-600 rounded-lg appearance-none cursor-pointer accent-sky-500" />
              <span className={`text-xs font-bold w-6 h-6 rounded flex items-center justify-center ${blinkActive ? 'bg-sky-500 text-white' : 'bg-slate-700'}`}>B</span>
            </div>
            <ZoomControls />
          </div>
        );

        if (mode === ComparisonMode.LOUPE) return (
          <div ref={containerRef} className="w-full h-full relative overflow-hidden cursor-none bg-slate-900" onMouseMove={handleMouseMove}>
            <img src={leftImage.url} style={imgStyle} className="opacity-50 grayscale-[0.5]" />
            <div className="absolute w-64 h-64 rounded-full border-4 border-sky-500 shadow-2xl overflow-hidden pointer-events-none z-50 bg-black" style={{ left: mousePos.x - 128, top: mousePos.y - 128 }}>
              <div className="relative w-full h-full">
                <img src={rightImage.url} style={{ position: 'absolute', width: containerRef.current?.offsetWidth, height: containerRef.current?.offsetHeight, maxWidth: 'none', left: -mousePos.x + 128, top: -mousePos.y + 128, objectFit: 'contain' }} />
                <div className="absolute inset-0 flex items-center justify-center opacity-30"><div className="w-full h-px bg-sky-500"></div><div className="h-full w-px bg-sky-500 absolute"></div></div>
              </div>
            </div>
          </div>
        );

        if (mode === ComparisonMode.ELA) return (
           <div className="w-full h-full flex gap-1 bg-slate-950 relative">
             {loading && <div className="absolute inset-0 z-50 flex items-center justify-center bg-slate-900/80"><span className="text-sky-400 animate-pulse">Procesando ELA...</span></div>}
             <div className="flex-1 relative border-r border-slate-800"><img src={elaA} className="w-full h-full object-contain" /><div className="absolute bottom-0 w-full bg-black/50 text-center text-xs py-1 text-slate-300">ELA Imagen A</div></div>
             <div className="flex-1 relative"><img src={elaB} className="w-full h-full object-contain" /><div className="absolute bottom-0 w-full bg-black/50 text-center text-xs py-1 text-slate-300">ELA Imagen B</div></div>
           </div>
        );

        if (mode === ComparisonMode.SLIDER) return (
          <div ref={containerRef} className="relative w-full h-full cursor-ew-resize overflow-hidden bg-slate-800" onMouseDown={handleMouseDown} onMouseUp={() => isDraggingSlider.current = false} onMouseMove={handleMouseMove}>
            <img src={rightImage.url} style={imgStyle} />
            <div className="absolute top-0 left-0 h-full overflow-hidden border-r-2 border-sky-500 bg-slate-800" style={{ width: `${sliderPosition}%` }}>
              <img src={leftImage.url} style={{ ...imgStyle, width: `${100 / (sliderPosition / 100)}%`, maxWidth: 'none' }} />
            </div>
            <div className="absolute top-0 bottom-0 w-8 -ml-4 flex items-center justify-center pointer-events-none z-10" style={{ left: `${sliderPosition}%` }}>
              <div className="w-8 h-8 rounded-full bg-sky-500 shadow-xl border-2 border-white flex items-center justify-center"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" className="w-4 h-4 text-white"><path d="m9 18 6-6-6-6"/><path d="m15 18-6-6 6-6"/></svg></div>
            </div>
          </div>
        );

        if (mode === ComparisonMode.OVERLAY) return (
          <div className="w-full h-full relative flex flex-col">
            <div className="flex-1 relative overflow-hidden bg-slate-800">
              <img src={leftImage.url} style={{...imgStyle, zIndex: 1}} />
              <img src={rightImage.url} style={{...imgStyle, zIndex: 2, opacity: opacity / 100}} />
            </div>
            <div className="absolute bottom-8 left-1/2 -translate-x-1/2 z-20 bg-slate-900/90 backdrop-blur px-6 py-3 rounded-full border border-slate-600 w-64">
               <input type="range" min="0" max="100" value={opacity} onChange={e => setOpacity(Number(e.target.value))} className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-sky-500" />
            </div>
          </div>
        );

        if (mode === ComparisonMode.DIFFERENCE) return (
          <div className="w-full h-full flex items-center justify-center bg-black relative">
            {loading && <div className="absolute inset-0 flex items-center justify-center bg-slate-900/80 text-sky-400">Calculando...</div>}
            {diffUrl && <img src={diffUrl} className="w-full h-full object-contain" />}
          </div>
        );

        return null;
      };

      const MetadataViewer = ({ title, image }) => {
        if (!image) return null;
        const formatSize = (b) => { const k=1024, i=Math.floor(Math.log(b)/Math.log(k)); return parseFloat((b/Math.pow(k,i)).toFixed(2)) + ' ' + ['Bytes','KB','MB','GB'][i]; };
        const formatDate = (d) => d ? new Date(d).toLocaleDateString() : 'N/A';
        const exposure = (t) => !t ? '--' : t >= 1 ? `${t}s` : `1/${Math.round(1/t)}`;

        return (
          <div className="text-sm">
             <div className="flex items-center gap-2 mb-4"><div className={`w-2 h-2 rounded-full ${title.includes('Izquierda')?'bg-sky-500':'bg-emerald-500'}`}></div><h4 className="font-bold">{title}</h4></div>
             <div className="bg-slate-900/50 rounded-lg p-3 mb-4 border border-slate-700/50 space-y-2">
               <h5 className="text-xs font-semibold text-slate-500 uppercase">Archivo</h5>
               <div className="flex justify-between text-slate-400"><span><Maximize size={14} className="inline mr-2"/>Res.</span><span className="text-slate-200 font-mono">{image.width}x{image.height}</span></div>
               <div className="flex justify-between text-slate-400"><span><HardDrive size={14} className="inline mr-2"/>Tamaño</span><span className="text-slate-200">{formatSize(image.size)}</span></div>
             </div>
             {image.exif && (
               <div className="bg-slate-900/50 rounded-lg p-3 mb-4 border border-slate-700/50">
                 <h5 className="text-xs font-semibold text-slate-500 uppercase mb-2"><Camera size={12} className="inline mr-1"/>Cámara</h5>
                 <div className="mb-3 font-medium">{image.exif.make} {image.exif.model}</div>
                 <div className="grid grid-cols-3 gap-2 text-center">
                   <div className="bg-slate-800 p-1 rounded"><div className="text-xs text-sky-400">f/</div>{image.exif.fNumber||'--'}</div>
                   <div className="bg-slate-800 p-1 rounded"><div className="text-xs text-sky-400">sec</div>{exposure(image.exif.exposureTime)}</div>
                   <div className="bg-slate-800 p-1 rounded"><div className="text-xs text-sky-400">ISO</div>{image.exif.iso||'--'}</div>
                 </div>
               </div>
             )}
             {image.exif?.latitude && (
               <div className="bg-slate-900/50 rounded-lg p-3 border border-slate-700/50 flex justify-between items-center">
                 <span className="text-xs"><MapPin size={12} className="inline mr-1"/>GPS</span>
                 <a href={`https://maps.google.com/?q=${image.exif.latitude},${image.exif.longitude}`} target="_blank" className="text-xs bg-blue-600 px-2 py-1 rounded hover:bg-blue-500">Ver Mapa</a>
               </div>
             )}
          </div>
        );
      };

      const AIAnalyzer = ({ leftImage, rightImage, onLoadToViewer }) => {
        const [tab, setTab] = useState('analyze');
        const [analysis, setAnalysis] = useState(null);
        const [loading, setLoading] = useState(false);
        const [editTarget, setEditTarget] = useState('right');
        const [preset, setPreset] = useState('');
        const [prompt, setPrompt] = useState('');
        const [genImg, setGenImg] = useState(null);
        const [error, setError] = useState(null);

        const analyze = async () => {
          setLoading(true); setError(null);
          try { setAnalysis(await analyzeImageDifference(leftImage, rightImage)); }
          catch (e) { setError('Error en Gemini API'); }
          finally { setLoading(false); }
        };

        const edit = async () => {
          setLoading(true); setError(null); setGenImg(null);
          try {
             const p = preset || prompt;
             if (!p) return;
             setGenImg(await editImageWithGenAI(editTarget === 'left' ? leftImage : rightImage, p));
          } catch (e) { setError('Error generando imagen'); }
          finally { setLoading(false); }
        };

        return (
          <div className="flex flex-col h-full">
            <div className="flex border-b border-slate-700 mb-4">
              <button onClick={() => setTab('analyze')} className={`flex-1 py-2 text-sm font-medium ${tab === 'analyze' ? 'text-indigo-400 border-b-2 border-indigo-400' : 'text-slate-500'}`}>Análisis</button>
              <button onClick={() => setTab('edit')} className={`flex-1 py-2 text-sm font-medium ${tab === 'edit' ? 'text-sky-400 border-b-2 border-sky-400' : 'text-slate-500'}`}>Edición</button>
            </div>
            {error && <div className="bg-red-900/30 text-red-200 p-2 rounded text-xs mb-3">{error}</div>}
            
            {tab === 'analyze' ? (
               <div className="flex flex-col h-full">
                 {!analysis ? (
                   <div className="flex flex-col items-center justify-center flex-1 text-slate-400 gap-3">
                      <Sparkles size={32} />
                      <button onClick={analyze} disabled={loading} className="bg-indigo-600 text-white px-4 py-2 rounded-lg text-sm font-bold">{loading ? 'Analizando...' : 'Analizar Diferencias'}</button>
                   </div>
                 ) : (
                   <div className="text-xs text-slate-300 whitespace-pre-wrap overflow-y-auto flex-1 pr-2">{analysis}</div>
                 )}
               </div>
            ) : (
               <div className="flex flex-col gap-3">
                 <div className="flex gap-2 bg-slate-800 p-2 rounded">
                   <button onClick={() => setEditTarget('left')} className={`flex-1 text-xs py-1 rounded ${editTarget==='left' ? 'bg-sky-600 text-white' : 'text-slate-400'}`}>Imagen A</button>
                   <button onClick={() => setEditTarget('right')} className={`flex-1 text-xs py-1 rounded ${editTarget==='right' ? 'bg-sky-600 text-white' : 'text-slate-400'}`}>Imagen B</button>
                 </div>
                 <select value={preset} onChange={e => {setPreset(e.target.value); setPrompt('')}} className="bg-slate-800 border border-slate-700 rounded p-2 text-xs text-white w-full">
                   {PHOTO_PRESETS.map((p, i) => <option key={i} value={p.prompt}>{p.label}</option>)}
                 </select>
                 <textarea placeholder="O describe el cambio..." value={prompt} onChange={e => {setPrompt(e.target.value); setPreset('')}} className="bg-slate-800 border border-slate-700 rounded p-2 text-xs text-white h-16 w-full" />
                 <button onClick={edit} disabled={loading || (!preset && !prompt)} className="bg-sky-600 hover:bg-sky-500 text-white py-2 rounded text-sm font-bold flex items-center justify-center gap-2">
                   {loading ? <RefreshCw className="animate-spin" size={14}/> : <Wand2 size={14}/>} {loading ? 'Generando...' : 'Aplicar'}
                 </button>
                 {genImg && (
                   <div className="bg-slate-800 rounded border border-slate-700 p-2 animate-in fade-in">
                      <img src={genImg} className="w-full h-32 object-contain mb-2 rounded bg-black/40" />
                      <div className="flex gap-2">
                         <button onClick={() => onLoadToViewer(genImg, 'left')} className="flex-1 bg-slate-700 hover:bg-slate-600 text-white text-xs py-1 rounded flex items-center justify-center gap-1"><ArrowLeft size={12}/> Cargar en A</button>
                         <button onClick={() => onLoadToViewer(genImg, 'right')} className="flex-1 bg-slate-700 hover:bg-slate-600 text-white text-xs py-1 rounded flex items-center justify-center gap-1">Cargar en B <ArrowRight size={12}/></button>
                      </div>
                   </div>
                 )}
               </div>
            )}
          </div>
        );
      };

      const App = () => {
        const [leftImage, setLeftImage] = useState(null);
        const [rightImage, setRightImage] = useState(null);
        const [mode, setMode] = useState(ComparisonMode.SLIDER);
        const [showMetadata, setShowMetadata] = useState(false);
        const [showAI, setShowAI] = useState(false);

        const handleImageLoad = async (file, side) => {
          const url = URL.createObjectURL(file);
          let exif = undefined;
          try { 
             const output = await exifr.parse(file, {tiff:true, exif:true, gps:true});
             if (output) exif = { make: output.Make, model: output.Model, exposureTime: output.ExposureTime, fNumber: output.FNumber, iso: output.ISO, latitude: output.latitude, longitude: output.longitude };
          } catch (e) { console.warn(e); }

          const img = new Image();
          img.onload = () => {
            const data = { id: crypto.randomUUID(), file, url, width: img.width, height: img.height, type: file.type, size: file.size, lastModified: file.lastModified, exif };
            side === 'left' ? setLeftImage(data) : setRightImage(data);
          };
          img.src = url;
        };

        const handleLoadFromAI = async (base64, side) => {
           const res = await fetch(base64);
           const blob = await res.blob();
           const file = new File([blob], `ai_edit_${Date.now()}.png`, { type: 'image/png' });
           handleImageLoad(file, side);
        };

        const hasBoth = !!leftImage && !!rightImage;

        return (
          <div className="flex flex-col h-full bg-slate-900 text-slate-100 font-sans">
            <Header mode={mode} setMode={setMode} hasImages={hasBoth} showMetadata={showMetadata} toggleMetadata={() => setShowMetadata(!showMetadata)} showAI={showAI} toggleAI={() => setShowAI(!showAI)} />
            <main className="flex-1 relative overflow-hidden flex flex-row">
              <div className="flex-1 flex flex-col relative z-10">
                {!hasBoth ? (
                  <div className="flex-1 flex flex-col md:flex-row p-4 gap-4 items-center justify-center">
                    <DropZone side="left" image={leftImage} onFileLoaded={f => handleImageLoad(f, 'left')} onRemove={() => setLeftImage(null)} />
                    <DropZone side="right" image={rightImage} onFileLoaded={f => handleImageLoad(f, 'right')} onRemove={() => setRightImage(null)} />
                  </div>
                ) : (
                  <div className="flex-1 relative w-full h-full bg-slate-950 flex items-center justify-center overflow-hidden p-4">
                    <button onClick={() => {setLeftImage(null); setRightImage(null)}} className="absolute top-4 left-4 z-50 bg-slate-800/80 p-2 rounded-full text-xs border border-slate-600 hover:bg-slate-700 transition-colors">Reiniciar</button>
                    <ImageViewer leftImage={leftImage} rightImage={rightImage} mode={mode} />
                  </div>
                )}
              </div>
              {showMetadata && (
                <aside className="w-80 bg-slate-800 border-l border-slate-700 flex flex-col overflow-y-auto shadow-xl z-20">
                   <div className="p-4 border-b border-slate-700 font-semibold text-sky-400 flex items-center gap-2"><Info size={18}/> Detalles</div>
                   <div className="p-4 space-y-8">
                     <MetadataViewer title="Imagen Izquierda (A)" image={leftImage} />
                     <div className="w-full h-px bg-slate-700"></div>
                     <MetadataViewer title="Imagen Derecha (B)" image={rightImage} />
                   </div>
                </aside>
              )}
              {showAI && hasBoth && (
                <aside className="w-96 bg-slate-900 border-l border-indigo-500/30 flex flex-col shadow-2xl z-30 absolute right-0 top-0 bottom-0">
                   <div className="p-4 border-b border-indigo-500/30 bg-indigo-900/20 font-semibold text-indigo-300 flex items-center gap-2"><Sparkles size={18}/> Gemini AI</div>
                   <div className="p-4 flex-1 overflow-hidden">
                     <AIAnalyzer leftImage={leftImage} rightImage={rightImage} onLoadToViewer={handleLoadFromAI} />
                   </div>
                </aside>
              )}
            </main>
          </div>
        );
      };

      const root = createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>